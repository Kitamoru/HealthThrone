import { NextApiRequest, NextApiResponse } from 'next';
import { prisma } from '@/lib/prisma';
import { getAiInterpretation } from '@/lib/groq';

// Маппинг классов на архетипы Бартла
const CLASS_ARCHETYPES: Record<string, string> = {
  // Разработчик
  'Мастер алгоритмов': 'достигатор',
  'Искатель оптимизации': 'исследователь',
  'Бард коллаборации': 'социализатор',
  'Разрушитель багов': 'киллер',

  // Инженер по безопасности
  'Страж уязвимостей': 'достигатор',
  'Шпион угроз': 'исследователь',
  'Проповедник безопасности': 'социализатор',
  'Охотник за угрозами': 'киллер',

  // Тестер
  'Мастер покрытия': 'достигатор',
  'Ловец багов': 'исследователь',
  'Посол качества': 'социализатор',
  'Испытатель пределов': 'киллер',

  // Аналитик
  'Заклинатель метрик': 'достигатор',
  'Алхимик данных': 'исследователь',
  'Рассказчик инсайтов': 'социализатор',
  'Разрушитель иллюзий': 'киллер',

  // Дизайнер
  'Ясновидящий': 'достигатор',
  'Картограф опыта': 'исследователь',
  'Глас народа': 'социализатор',
  'Разрушитель хаоса': 'киллер',

  // Продакт менеджер
  'Завоеватель рынков': 'достигатор',
  'Провидец рынка': 'исследователь',
  'Миротворец стейкхолдеров': 'социализатор',
  'Балансир спринтов': 'киллер',

  // Менеджер проектов
  'Мастер дедлайнов': 'достигатор',
  'Навигатор хаоса': 'исследователь',
  'Дирижер команды': 'социализатор',
  'Разрушитель преград': 'киллер',

  // Скрам мастер
  'Хранитель скорости': 'достигатор',
  'Призыватель кайдзенов': 'исследователь',
  'Мастер церемоний': 'социализатор',
  'Охотник на импедансы': 'киллер',

  // Тимлид
  'Архитектор роста': 'достигатор',
  'Навигатор развития': 'исследователь',
  'Наставник гильдии': 'социализатор',
  'Щит команды': 'киллер',

  // Техлид
  'Архимаг качества': 'достигатор',
  'Проводник технологий': 'исследователь',
  'Мудрец кода': 'социализатор',
  'Судья техдолга': 'киллер',

  // Саппорт
  'Волшебник поддержки': 'достигатор',
  'Хранитель истины': 'исследователь',
  'Посол доверия': 'социализатор',
  'Охотник за SLA': 'киллер',

  // Девопс
  'Страж стабильности': 'достигатор',
  'Алхимик инфраструктуры': 'исследователь',
  'Говорящий с духами': 'социализатор',
  'Укротитель инцидентов': 'киллер',

  // Архитектор
  'Мудрец систем': 'достигатор',
  'Советник будущего': 'исследователь',
  'Проповедник смыслов': 'социализатор',
  'Искатель антипаттернов': 'киллер',

  // Аккаунт менеджер
  'Зачарователь сделок': 'достигатор',
  'Картограф потребностей': 'исследователь',
  'Повелитель отношений': 'социализатор',
  'Охотник за возражениями': 'киллер',

  // Менеджер по продажам
  'Торговец судьбы': 'достигатор',
  'Коллекционер путей': 'исследователь',
  'Хранитель связей': 'социализатор',
  'Повелитель желаний': 'киллер',

  // C-level
  'Повелитель ресурсов': 'достигатор',
  'Провидец': 'исследователь',
  'Связующий звезды': 'социализатор',
  'Убийца стагнации': 'киллер',

  // HR
  'Инженер талантов': 'достигатор',
  'Картограф мотивации': 'исследователь',
  'Изгнанник выгорания': 'социализатор',
  'Охотник за головами': 'киллер',
};

function getClassArchetype(className: string): string {
  return CLASS_ARCHETYPES[className] || 'достигатор'; // по умолчанию
}

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method !== 'POST') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  try {
    const { userId } = req.body;

    if (!userId) {
      return res.status(400).json({ error: 'ID пользователя не предоставлен' });
    }

    if (isNaN(Number(userId))) {
      return res.status(400).json({ error: 'Некорректный ID пользователя' });
    }

    const profile = await prisma.users.findUnique({
      where: { telegram_id: BigInt(userId) },
      include: { octalysis_factors: true }
    });

    if (!profile) {
      return res.status(404).json({ error: 'Профиль героя не найден. Сначала зарегистрируйтесь!' });
    }

    if (!profile.octalysis_factors) {
      return res.status(400).json({ error: 'Данные мотивации не найдены. Пройдите ежедневное испытание!' });
    }

    const stats = profile.octalysis_factors;
    const statsForAi = {
      factor1: Number(stats.factor1),
      factor2: Number(stats.factor2),
      factor3: Number(stats.factor3),
      factor4: Number(stats.factor4),
      factor5: Number(stats.factor5),
      factor6: Number(stats.factor6),
      factor7: Number(stats.factor7),
      factor8: Number(stats.factor8),
    };

    const className = profile.character_class || '';
    const archetype = getClassArchetype(className);

    const advice = await getAiInterpretation(statsForAi, className, archetype);

    if (!advice) {
      throw new Error('GigaChat вернул пустой ответ');
    }

    return res.status(200).json({ success: true, advice });
  } catch (error: any) {
    console.error('[API ERROR]', error);
    return res.status(500).json({ error: 'Ошибка сервера', details: error.message });
  }
}
