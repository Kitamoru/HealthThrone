// pages/api/generate-questions.ts
import type { NextApiRequest, NextApiResponse } from 'next';
import { Groq } from 'groq-sdk';

const groq = new Groq({ apiKey: process.env.GROQ_API_KEY });

const STATIC_QUESTIONS = [
  { id: 1,  text: "Сумели ли вы сегодня удержаться на ногах под натиском тёмных сил?" },
  { id: 2,  text: "Чувствовали ли вы сегодня, что пламя в вашей душе горит ярко, а свершения наполняют вас радостью?" },
  { id: 3,  text: "Ощущали ли вы сегодня, что служите великой цели гильдии, а не просто выполняете команды гильдмастера?" },
  { id: 4,  text: "Чувствовали ли вы сегодня, что сами держите штурвал своего корабля, а не ведомы чужой волей?" },
  { id: 5,  text: "Чувствовали ли вы сегодня, что ваш голос или действия повлияли на решения или дух отряда?" },
  { id: 6,  text: "Преподнес ли сегодняшний день неожиданную встречу, загадку или событие, что пробудило Ваш интерес?" },
  { id: 7,  text: "Помогло ли вам сегодня ощущение, что промедление может стоить вам важного шанса или артефакта?" },
  { id: 8,  text: "Придавали ли вам энергии сегодня редкие ресурсы или срочные вызовы?" },
  { id: 9,  text: "Удалось ли вам сегодня завладеть новым ценным трофеем, артефактом, или знанием, усиливающим вашу мощь?" },
  { id: 10, text: "Смогли ли вы сегодня продвинуться в мастерстве или заслужить признание от других героев?" },
];

type Question = { id: number; text: string };

function normalizeAndSort(raw: unknown): Question[] {
  if (!Array.isArray(raw)) return STATIC_QUESTIONS;

  const valid: Question[] = raw
    .map((item: unknown) => {
      if (typeof item !== 'object' || item === null) return null;
      const q = item as Record<string, unknown>;
      const id = typeof q.id === 'number' ? q.id : Number(q.id);
      const text = typeof q.text === 'string' ? q.text.trim() : '';
      if (!Number.isFinite(id) || id < 1 || id > 10 || !text) return null;
      return { id, text };
    })
    .filter((q): q is Question => q !== null);

  if (valid.length !== 10) return STATIC_QUESTIONS;

  return valid.sort((a, b) => a.id - b.id);
}

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method !== 'POST') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  const { userId } = req.body;
  if (!userId) {
    return res.status(400).json({ error: 'Missing userId' });
  }

  try {
    const prompt = `Ты — мастер подземелий, ведущий летопись героев великой гильдии. Каждый день ты задаёшь воинам вопросы об их духовном состоянии, используя язык фэнтезийного эпоса.

СТИЛЬ И ЯЗЫК — это самое важное:
- Обращение всегда на "вы" (почтительное, эпическое).
- Вопросы начинаются с глагольных форм: "Сумели ли вы...", "Чувствовали ли вы...", "Ощущали ли вы...", "Удалось ли вам...", "Преподнёс ли...", "Помогло ли вам...".
- Рабочие понятия заменяются фэнтезийными: работа → "служение"/"походы"/"свершения", коллеги → "отряд"/"братья по оружию", руководитель → "гильдмастер"/"командир", цель → "великая миссия"/"путь героя", ресурсы → "артефакты"/"трофеи"/"редкие свитки", навыки → "мастерство"/"умения", усталость/выгорание → "натиск тёмных сил"/"угасание пламени".
- Язык — возвышенный, образный, с метафорами огня, тьмы, света, битвы, пути.
- Каждый вопрос — одно предложение, заканчивается знаком "?".
- Вопрос должен звучать так, будто задаётся у костра после долгого похода.

ПРИМЕР ПРАВИЛЬНОГО СТИЛЯ (точно такой тон):
"Сумели ли вы сегодня удержаться на ногах под натиском тёмных сил?"
"Чувствовали ли вы сегодня, что пламя в вашей душе горит ярко, а свершения наполняют вас радостью?"
"Ощущали ли вы сегодня, что служите великой цели гильдии, а не просто выполняете команды гильдмастера?"
"Удалось ли вам сегодня завладеть новым ценным трофеем, артефактом или знанием, усиливающим вашу мощь?"

ЗАПРЕЩЕНО использовать: офисные слова ("задача", "проект", "дедлайн", "коллеги", "продуктивность", "эффективность", "мотивация"), современные реалии, нейтральный бытовой язык.

СТРУКТУРА — 10 вопросов строго по факторам:
1. Burnout: способность противостоять трудностям и тёмным силам.
2. Burnout: ощущение радости, энергии и яркости пламени внутри.
3. Эпическое предназначение — служение великой цели, а не слепое следование приказам.
4. Автономия — ощущение, что герой сам держит штурвал своей судьбы.
5. Социальное влияние — голос и действия героя изменили дух отряда.
6. Непредсказуемость — неожиданное событие, загадка или встреча пробудили интерес.
7. Дефицит — осознание, что промедление грозит потерей редкого шанса.
8. Срочность — редкие ресурсы или вызовы придавали силу и энергию.
9. Владение — герой добыл новый трофей, артефакт или знание.
10. Развитие — продвижение в мастерстве или признание от других героев.

    Важно: вопросы 1 и 2 будут влиять на уровень "выгорания" (burnout). Они должны отражать: первый — способность противостоять трудностям, второй — ощущение радости и энергии.
    Остальные вопросы (3–10) соответствуют восьми факторам в том же порядке, что и выше.

    Верни строго JSON-объект с ключом "questions", содержащий массив из 10 объектов, каждый с полями "id" (число от 1 до 10) и "text" (строка с вопросом). Никакого дополнительного текста.
    Пример формата:
    {
      "questions": [
        {"id": 1, "text": "Сумели ли вы сегодня удержаться на ногах под натиском тёмных сил?"},
        {"id": 2, "text": "Чувствовали ли вы сегодня, что пламя в вашей душе горит ярко, а свершения наполняют вас радостью?"}
      ]
    }`;

    const completion = await groq.chat.completions.create({
      messages: [{ role: 'user', content: prompt }],
      model: 'llama-3.3-70b-versatile',
      temperature: 0.75,
      top_p: 0.9,
      max_tokens: 1024,
      response_format: { type: 'json_object' },
    });

    const content = completion.choices[0]?.message?.content;
    if (!content) throw new Error('Empty response from Groq');

    const parsed = JSON.parse(content);
    const raw = Array.isArray(parsed) ? parsed : parsed.questions;

    const questions = normalizeAndSort(raw);

    return res.status(200).json({ questions });
  } catch (error) {
    console.error('Question generation error:', error);
    return res.status(200).json({ questions: STATIC_QUESTIONS });
  }
}
