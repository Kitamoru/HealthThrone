// pages/api/generate-questions.ts
import type { NextApiRequest, NextApiResponse } from 'next';
import { Groq } from 'groq-sdk';

const groq = new Groq({ apiKey: process.env.GROQ_API_KEY });

// Описание каждого фактора для промпта (можно расширить)
const factorDescriptions = [
  { id: 1, desc: 'Эпическое предназначение (Calling) – ощущение, что ты часть чего-то великого' },
  { id: 2, desc: 'Развитие и достижение (Development & Accomplishment) – чувство прогресса, мастерства' },
  { id: 3, desc: 'Расширение творчества (Empowerment of Creativity) – возможность влиять, творить' },
  { id: 4, desc: 'Владение и обладание (Ownership & Possession) – накопление ресурсов, артефактов' },
  { id: 5, desc: 'Социальное влияние (Social Influence) – взаимодействие, признание' },
  { id: 6, desc: 'Дефицит и нетерпение (Scarcity & Impatience) – ограниченность, срочность' },
  { id: 7, desc: 'Непредсказуемость и любопытство (Unpredictability & Curiosity) – сюрпризы, открытия' },
  { id: 8, desc: 'Потеря и избегание (Loss & Avoidance) – страх потери, упущенных возможностей' },
];

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method !== 'POST') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  const { userId, initData } = req.body;
  if (!userId) {
    return res.status(400).json({ error: 'Missing userId' });
  }

  // Здесь можно добавить проверку initData (Telegram WebApp)

  try {
    // Формируем промпт для генерации 10 вопросов
    const prompt = `Ты — мастер подземелий в игре, где игроки ежедневно отвечают на вопросы о своей мотивации. 
    Нужно сгенерировать 10 вопросов на русском языке, каждый из которых соответствует одному из факторов геймификации Octalysis.
    Каждый вопрос должен быть сформулирован иначе, чем в предыдущие разы, но сохранять связь с фактором.
    Вот факторы и их краткое описание:
    1. Эпическое предназначение (Calling) — вопросы о служении великой цели, вере в миссию.
    2. Развитие и достижение — вопросы о прогрессе, росте навыков, получении наград.
    3. Расширение творчества — вопросы о возможности влиять, принимать решения, выражать себя.
    4. Владение и обладание — вопросы о накоплении ресурсов, артефактов, знаний.
    5. Социальное влияние — вопросы о взаимодействии, помощи другим, признании.
    6. Дефицит и нетерпение — вопросы о срочности, ограниченности во времени, редких шансах.
    7. Непредсказуемость и любопытство — вопросы о неожиданностях, открытиях, тайнах.
    8. Потеря и избегание — вопросы о страхе упустить возможность, потерять достигнутое.

    Важно: вопросы 1 и 2 будут влиять на уровень "выгорания" (burnout). Они должны отражать: первый — способность противостоять трудностям, второй — ощущение радости и энергии.
    Остальные вопросы (3–10) соответствуют восьми факторам в том же порядке, что и выше.

    Верни строго JSON-массив из 10 объектов, каждый с полями "id" (число от 1 до 10) и "text" (строка с вопросом). Никакого дополнительного текста.
    Пример формата:
    [
      {"id": 1, "text": "Сумели ли вы сегодня удержаться на ногах под натиском тёмных сил?"},
      {"id": 2, "text": "Чувствовали ли вы сегодня, что пламя в вашей душе горит ярко, а свершения наполняют вас радостью?"},
      ...
    ]`;

    const completion = await groq.chat.completions.create({
      messages: [{ role: 'user', content: prompt }],
      model: 'llama-3.3-70b-versatile', // или другая модель
      temperature: 0.65,
      max_tokens: 1024,
      response_format: { type: 'json_object' },
    });

    const content = completion.choices[0]?.message?.content;
    if (!content) throw new Error('Empty response from Groq');

    // Парсим JSON
    const questions = JSON.parse(content);
    if (!Array.isArray(questions) || questions.length !== 10) {
      throw new Error('Invalid response format');
    }

    // Можно добавить валидацию: все ли id присутствуют, текст не пустой
    return res.status(200).json({ questions });
  } catch (error) {
    console.error('Question generation error:', error);
    // В случае ошибки возвращаем статические вопросы как запасной вариант
    return res.status(200).json({ questions: QUESTIONS }); // QUESTIONS импортировать из статики
  }
}
